library("ggplot2")
library("hexbin")
library("RColorBrewer")
library("MASS")

# ubuntu
setwd("/home/bo/Desktop/deeplearning/Project")
# mac
# setwd("/Users/alexpb/Desktop/Course/820/deeplearning/Project")


createGGPlotInternal <- function(ccmXYIncludingNonnegColumn, isDisplayMAE, isTruncatePerRealizationRho)
{
  if (isDisplayMAE)
    gPlot <- ggplot(ccmXYIncludingNonnegColumn, aes(x=lib_size, y=mae))
  else
  {
    if (isTruncatePerRealizationRho)
      gPlot <- ggplot(ccmXYIncludingNonnegColumn, aes(x=lib_size, y=nonnegRho))
    else
      gPlot <- ggplot(ccmXYIncludingNonnegColumn, aes(x=lib_size, y=rho)) 
  }
  
  return(gPlot)  
}



createPerRealizationPlot <- function(ccmXYIncludingNonnegColumn, strXDescription=ccmXYIncludingNonnegColumn$lib_column[1], strYDescription=ccmXYIncludingNonnegColumn$target_column[1], isTruncatePerRealizationRho=FALSE, isDisplayMAE=FALSE)
{
  EEmbeddingDimension = ccmXYIncludingNonnegColumn$E[1] 
  countSamplesPerL = ccmXYIncludingNonnegColumn$num_pred[1]
  
  strTitle = paste(strXDescription, " xmap ", strYDescription, "(E", EEmbeddingDimension, ",", countSamplesPerL, " samples)")
  
  gPlot <- createGGPlotInternal(ccmXYIncludingNonnegColumn, isDisplayMAE, isTruncatePerRealizationRho)
  gPlot + geom_point() +  geom_smooth(se=TRUE) + stat_quantile(quantiles=c(0.05, 0.25,0.5,0.75,0.95)) + ggtitle(strTitle)
}







createPerRealizationDensityPlot <- function(ccmXYIncludingNonnegColumn, strXDescription=ccmXYIncludingNonnegColumn$lib_column[1], strYDescription=ccmXYIncludingNonnegColumn$target_column[1], isTruncatePerRealizationRho=FALSE, isDisplayMAE=FALSE)
{
  EEmbeddingDimension = ccmXYIncludingNonnegColumn$E[1] 
  countSamplesPerL = ccmXYIncludingNonnegColumn$num_pred[1]
  tau = ccmXYIncludingNonnegColumn$tau[1] 
  
  vecColours <- colorRampPalette(rev(brewer.pal(10,'Spectral')))(50)
  strTitle = paste(strXDescription, " xmap ", strYDescription, "(E", EEmbeddingDimension, ",", "tau", tau, ",", countSamplesPerL, " samples)")
  
  uniqueLibrarySizes <- unique(ccmXYIncludingNonnegColumn$lib_size)
  maxLibrarySize <- max(uniqueLibrarySizes)
  # because there can be an extra small number in the transition between from the short step size to the longer one, to get the smallest
  # standard step size, get the SECOND smallest one
  smallestStandardStepL <- diff(uniqueLibrarySizes)[2]
  
  countDistinctLibrarySizes <- maxLibrarySize/smallestStandardStepL
  countRhoBins <- 100
  
  gPlot <- createGGPlotInternal(ccmXYIncludingNonnegColumn, isDisplayMAE, isTruncatePerRealizationRho)
  
  #  print(countDistinctLibrarySizes)
  png(strTitle)
  result <- gPlot + stat_bin2d(bins=c(countDistinctLibrarySizes, countRhoBins)) + scale_fill_gradientn(colours=vecColours)
  # result <- gPlot + stat_bin2d(bins=c(countDistinctLibrarySizes, countRhoBins)) + scale_fill_gradientn(colours=vecColours) + ggtitle(strTitle);
  print(result);
  #  countDistinctLibrarySizes <- length(unique(ccmXYIncludingNonnegColumn$lib_size))
}



createDensityPlotsFromAllPairs4DAnalysis <- function(resultsAllPairsAnalysis, isDisplayMAE=FALSE)
{
  # we proceed down the upper-diagonal matrix of possible matches
  # pairwise with w
  # w and x
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsWX, isDisplayMAE=isDisplayMAE);
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsXW, isDisplayMAE=isDisplayMAE);
  
  # w and y
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsWY, isDisplayMAE=isDisplayMAE);
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsYW, isDisplayMAE=isDisplayMAE);
  
  # w and z
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsWZ, isDisplayMAE=isDisplayMAE)
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsZW, isDisplayMAE=isDisplayMAE)
  
  
  # pairwise with x
  # x and y
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsXY, isDisplayMAE=isDisplayMAE);
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsYX, isDisplayMAE=isDisplayMAE);
  
  # x and z
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsXZ, isDisplayMAE=isDisplayMAE)
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsZX, isDisplayMAE=isDisplayMAE)
  
  # finally, pairwise with y
  # y and z
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsYZ, isDisplayMAE=isDisplayMAE)
  createPerRealizationDensityPlot(resultsAllPairsAnalysis$resultsZY, isDisplayMAE=isDisplayMAE)
}



# The below can be used to plot results generated by performStandardStockFlowCCMByEFor4VariableSystem (and similar functions in the future using a PARTICULAR set of variables, rather than exploring many such sets of variables)
createDensityPlotsFromStandardSweepSingleAllPairsAnalysisFor4VariableSystem <- function(resultsStandardSweepSingleAllPairsAnalysisFor4VariableSystem, isDisplayMAE=FALSE)
{
  vecCCM_resultsBySweptVariable = resultsStandardSweepSingleAllPairsAnalysisFor4VariableSystem$vecCCM_resultsBySweptVariable
  for (i in seq(1, length(vecCCM_resultsBySweptVariable)))
  {
    createDensityPlotsFromAllPairs4DAnalysis(vecCCM_resultsBySweptVariable[[i]], isDisplayMAE=isDisplayMAE)
  } 
}


createDensityPlotsFromStandardNonSweepAnalysisFor4VariableSystem <- function(resultsStandardNonSweepAnalysisFor4VariableSystem, isDisplayMAE=FALSE)
{
  createDensityPlotsFromAllPairs4DAnalysis(resultsStandardNonSweepAnalysisFor4VariableSystem$sensitivityResultsForRawVariables, isDisplayMAE=isDisplayMAE)
  createDensityPlotsFromAllPairs4DAnalysis(resultsStandardNonSweepAnalysisFor4VariableSystem$sensitivityResultsForAllVariablesFirstDifferenced, isDisplayMAE=isDisplayMAE)
  createDensityPlotsFromAllPairs4DAnalysis(resultsStandardNonSweepAnalysisFor4VariableSystem$sensitivityResultsForFlowVariablesFirstDifferenced, isDisplayMAE=isDisplayMAE)
}





# for every set -> causal category
start_time <- Sys.time()

load("./RData/resultsSymmetricSweepAnalysisPredPreyVariant.RData")

# the below creates the density plots from this
createDensityPlotsFromStandardSweepSingleAllPairsAnalysisFor4VariableSystem(resultsSymmetricSweepAnalysisPredPreyVariant)

end_time <- Sys.time()

print(paste("Duration: ", toString(end_time - start_time)))

